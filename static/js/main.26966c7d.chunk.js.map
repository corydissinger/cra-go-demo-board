{"version":3,"sources":["store/middleware/logger.js","game/utils.js","game/flags.js","store/reducers/board.js","store/constants/actions.js","game/maths.js","store/reducers/game.js","store/actions/board.js","Board.js","store/actions/game.js","ConfigurationPanel.js","ConfigurationTitleTab.js","App.js","index.js","store/configureStore.js"],"names":["logger","store","next","action","console","group","type","info","result","log","getState","groupEnd","genCharArray","charA","charZ","a","i","charCodeAt","j","push","String","fromCharCode","length","Error","concat","getCharacterFromOffset","offset","getOffsetFromCharacter","character","GOBAN_WIDTH_TO_HEIGHT_RATIO","Number","GOBAN_HEIGHT_TO_WIDTH_RATIO","GOBAN_STONE_DIAMETER_TO_TILE_HEIGHT_RATIO","CORNER_ALL_NW","CORNER_9_x_9_NE","CORNER_9_x_9_SE","CORNER_9_x_9_SW","CORNER_13_x_13_NE","CORNER_13_x_13_SE","CORNER_13_x_13_SW","CORNER_19_x_19_NE","CORNER_19_x_19_SE","CORNER_19_x_19_SW","CORNERS_9_x_9","STAR_POINTS_9_x_9","CORNERS_13_x_13","STAR_POINTS_13_x_13","CORNERS_19_x_19","STAR_POINTS_19_x_19","SIDES_9_x_9","Object","toConsumableArray","_","row","UTILS","col","SIDES_13_x_13","SIDES_19_x_19","GRID_COORDINATES_9_x_9","GRID_COORDINATES_13_x_13","GRID_COORDINATES_19_x_19","initialState","alteredStones","Set","mode","koViolation","currentBoardState","previousBoardState","previousStone","penultimateStone","board","state","arguments","undefined","payload","objectSpread","_action$payload","nextBoardState","placedStone","_action$payload2","colCoordinate","rowCoordinate","getCardinalDirection","coordinate","FLAGS","substring","getCardinalAdjacencies","_ref3","coordinates","maxIndex","colIndex","parseInt","rowIndex","adjacencies","north","east","south","west","getAdjacentCoordinates","_ref4","boardDimensions","height","width","canRender","configurationPanelShown","maxOffsets","tileDimensions","turnColor","turnNumber","windowHeight","windowWidth","blackCaptures","whiteCaptures","lastPreviewStone","getDimensions","_ref","desiredWidth","desiredHeight","Math","floor","GAME_MATHS","_ref2","boardHeight","boardWidth","tileRatio","game","_getDimensions","_getDimensions2","setStone","dispatch","_getState$game","_getState$board","color","_ref5","existingStones","newStoneColor","newStoneColCoordinate","newStoneRowCoordinate","opposingColor","newStones","defineProperty","cardinalAdjacencyMap","nextAdjacentCoordinates","attackedGroups","stones","liberties","isCoordinateProcessed","direction","shouldProcessCoordinate","attackedGroup","coordinateToProcess","apply","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Symbol","iterator","done","value","aCoordinate","err","return","stonesToRemove","survivingAttackedGroups","_i","_stonesToRemove","koWarning","_ref6","add","Board","props","_this","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","onMouseMove","bind","assertThisInitialized","onMouseOut","onClick","calculatePreviewStone","renderWholeBoard","prevProps","colOffset","rowOffset","canvasContext","getCanvasContextPresets","drawTile","clearRect","isKoViolation","refs","canvas","getContext","lineWidth","strokeStyle","_this$props","stonePlaced","clearCanvas","includes","drawIntersection","drawStarPoint","drawSide","drawCorner","drawStone","_this$props2","cardinalDirection","min_X","min_Y","mid_X","mid_Y","max_X","max_Y","beginPath","font","moveTo","lineTo","fillText","stroke","_this$props3","arc","PI","fillStyle","fill","drawStoneInternal","isBlack","_this$props4","stoneRadius","previousColOffset","previousRowOffset","_this$props5","setLastPreviewStone","currentColCoordinate","currentRowCoordinate","resetLastPreviewStone","aRow","_this2","numberCoordinate","letterCoordinate","_this3","getCoordinates","index","renderRow","x","y","_this$props6","offsets","_ref7","JSON","stringify","getOffsetsWithinBounds","e","showPreviewStone","_this$props7","clientX","clientY","theCoordinate","react_default","createElement","ref","Component","connect","tileHeight","_state$game","_state$board","ConfigurationPanel","setMode","panelClasses","id","className","href","getHumanReadableMode","onChange","target","ConfigurationTitleTab","showConfigurationPanel","App","updateWindowDimensions","window","addEventListener","removeEventListener","setWindowDimensions","innerWidth","innerHeight","src_ConfigurationTitleTab","src_Board","src_ConfigurationPanel","preloadedState","enhancers","applyMiddleware","thunkMiddleware","loggerMiddleware","composedEnhancers","composeWithDevTools","rootReducer","combineReducers","boardReducer","gameReducer","createStore","configureStore","rootElement","document","getElementById","ReactDOM","render","es","src_App"],"mappings":"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","file":"static/js/main.26966c7d.chunk.js","sourcesContent":["const logger = store => next => action => {\n    console.group(action.type);\n    console.info('dispatching', action);\n    let result = next(action);\n    console.log('next state', store.getState());\n    console.groupEnd();\n    return result;\n};\n\nexport default logger;","export const genCharArray = (charA, charZ) => {\n    let a = [], i = charA.charCodeAt(0), j = charZ.charCodeAt(0);\n\n    for (; i <= j; ++i) {\n        a.push(String.fromCharCode(i));\n    }\n\n    if (a.length === 0) {\n        throw new Error(`Unexpected begin [${charA}] and end [${charZ}] characters`);\n    }\n\n    return a;\n};\n\nexport const getCharacterFromOffset = (offset) => String.fromCharCode(offset + 97);\nexport const getOffsetFromCharacter = (character) => character.charCodeAt(0) - 97;","import * as _ from 'lodash';\nimport * as UTILS from './utils';\n\n// yeehaw constants and pointers and strings oh my\n\n// Ratios expertly calculated from here\n//https://senseis.xmp.net/?EquipmentDimensions\nexport const GOBAN_WIDTH_TO_HEIGHT_RATIO = Number(1.071428571428571);\nexport const GOBAN_HEIGHT_TO_WIDTH_RATIO = Number(0.933333333333333);\n\n// I made this up\nexport const GOBAN_STONE_DIAMETER_TO_TILE_HEIGHT_RATIO = Number(0.88);\n\nexport const TURN_BLACK = 'TURN_BLACK';\nexport const TURN_WHITE = 'TURN_WHITE';\n\nexport const STONE_NONE = 'STONE_NONE';\nexport const STONE_BLACK = 'STONE_BLACK';\nexport const STONE_WHITE = 'STONE_WHITE';\n\nexport const GAME_9_x_9 = 'GAME_9_x_9';\nexport const GAME_13_x_13 = 'GAME_13_x_13';\nexport const GAME_19_x_19 = 'GAME_19_x_19';\n\nexport const NORTH = 'NORTH';\nexport const NORTH_EAST = 'NORTH_EAST';\nexport const EAST = 'EAST';\nexport const SOUTH_EAST = 'SOUTH_EAST';\nexport const SOUTH = 'SOUTH';\nexport const SOUTH_WEST = 'SOUTH_WEST';\nexport const WEST = 'WEST';\nexport const NORTH_WEST = 'NORTH_WEST';\n\nexport const MIN_COLUMN = 'a';\nexport const MIN_SIDE_COLUMN = 'b';\nexport const MIN_ROW = '1';\n\nexport const MAX_9_x_9_COLUMN = 'i';\nexport const MAX_EASTWARD_9_x_9_COLUMN_FOR_NORTH_SOUTH = 'h';\nexport const MAX_9_x_9_ROW    = '9';\n\nexport const MAX_13_x_13_COLUMN = 'm';\nexport const MAX_EASTWARD_13_x_13_COLUMN_FOR_NORTH_SOUTH = 'l';\nexport const MAX_13_x_13_ROW    = '13';\n\nexport const MAX_19_x_19_COLUMN = 's';\nexport const MAX_EASTWARD_19_x_19_COLUMN_FOR_NORTH_SOUTH = 'r';\nexport const MAX_19_x_19_ROW    = '19';\n\n// it's always a1 doofus\nexport const CORNER_ALL_NW = `${MIN_COLUMN}${MIN_ROW}`;\n\nexport const CORNER_9_x_9_NE = `${MAX_9_x_9_COLUMN}${MIN_ROW}`;\nexport const CORNER_9_x_9_SE = `${MAX_9_x_9_COLUMN}${MAX_9_x_9_ROW}`;\nexport const CORNER_9_x_9_SW = `${MIN_COLUMN}${MAX_9_x_9_ROW}`;\n\nexport const CORNER_13_x_13_NE = `${MAX_13_x_13_COLUMN}${MIN_ROW}`;\nexport const CORNER_13_x_13_SE = `${MAX_13_x_13_COLUMN}${MAX_13_x_13_ROW}`;\nexport const CORNER_13_x_13_SW = `${MIN_COLUMN}${MAX_13_x_13_ROW}`;\n\nexport const CORNER_19_x_19_NE = `${MAX_19_x_19_COLUMN}${MIN_ROW}`;\nexport const CORNER_19_x_19_SE = `${MAX_19_x_19_COLUMN}${MAX_19_x_19_ROW}`;\nexport const CORNER_19_x_19_SW = `${MIN_COLUMN}${MAX_19_x_19_ROW}`;\n\nexport const CORNERS_9_x_9 = [\n    CORNER_ALL_NW,\n    CORNER_9_x_9_NE,\n    CORNER_9_x_9_SE,\n    CORNER_9_x_9_SW,\n];\n\nexport const STAR_POINTS_9_x_9 = [\n    'c3','g3','e5', 'c7', 'g7',\n];\n\nexport const CORNERS_13_x_13 = [\n    `${MIN_COLUMN}${MIN_ROW}`,\n    `${MIN_COLUMN}${MAX_13_x_13_ROW}`,\n    `${MAX_13_x_13_COLUMN}${MIN_ROW}`,\n    `${MAX_13_x_13_COLUMN}${MAX_13_x_13_ROW}`,\n];\n\nexport const STAR_POINTS_13_x_13 = [\n    'd4','j4','g7', 'j10', 'd10',\n];\n\nexport const CORNERS_19_x_19 = [\n    `${MIN_COLUMN}${MIN_ROW}`,\n    `${MIN_COLUMN}${MAX_19_x_19_ROW}`,\n    `${MAX_19_x_19_COLUMN}${MIN_ROW}`,\n    `${MAX_19_x_19_COLUMN}${MAX_19_x_19_ROW}`,\n];\n\nexport const STAR_POINTS_19_x_19 = [\n    'd4', 'd10', 'd16', 'j4', 'j10', 'j16', 'p4', 'p10', 'p16',\n];\n\nexport const SIDES_9_x_9 = [\n    ..._.map(_.range(2, 9), row => `${MIN_COLUMN}${row}`),\n    ..._.map(_.range(2, 9), row => `${MAX_9_x_9_COLUMN}${row}`),\n    ..._.map(UTILS.genCharArray(MIN_SIDE_COLUMN, MAX_EASTWARD_9_x_9_COLUMN_FOR_NORTH_SOUTH), col => `${col}9`),\n    ..._.map(UTILS.genCharArray(MIN_SIDE_COLUMN, MAX_EASTWARD_9_x_9_COLUMN_FOR_NORTH_SOUTH), col => `${col}1`),\n];\n\nexport const SIDES_13_x_13 = [\n    ..._.map(_.range(2, 13), row => `${MIN_COLUMN}${row}`),\n    ..._.map(_.range(2, 13), row => `${MAX_13_x_13_COLUMN}${row}`),\n    ..._.map(UTILS.genCharArray(MIN_SIDE_COLUMN, MAX_EASTWARD_13_x_13_COLUMN_FOR_NORTH_SOUTH), col => `${col}13`),\n    ..._.map(UTILS.genCharArray(MIN_SIDE_COLUMN, MAX_EASTWARD_13_x_13_COLUMN_FOR_NORTH_SOUTH), col => `${col}1`),\n];\n\nexport const SIDES_19_x_19 = [\n    ..._.map(_.range(2, 19), row => `${MIN_COLUMN}${row}`),\n    ..._.map(_.range(2, 19), row => `${MAX_19_x_19_COLUMN}${row}`),\n    ..._.map(UTILS.genCharArray(MIN_SIDE_COLUMN, MAX_EASTWARD_19_x_19_COLUMN_FOR_NORTH_SOUTH), col => `${col}19`),\n    ..._.map(UTILS.genCharArray(MIN_SIDE_COLUMN, MAX_EASTWARD_19_x_19_COLUMN_FOR_NORTH_SOUTH), col => `${col}1`),\n];\n\nexport const GRID_COORDINATES_9_x_9 =\n    _.map(_.range(1, 10), row => {\n        return _.map(UTILS.genCharArray(MIN_COLUMN, MAX_9_x_9_COLUMN), col => `${col}${row}`);\n    })\n;\n\nexport const GRID_COORDINATES_13_x_13 =\n    _.map(_.range(1, 14), row => {\n        return _.map(UTILS.genCharArray(MIN_COLUMN, MAX_13_x_13_COLUMN), col => `${col}${row}`);\n    })\n;\n\nexport const GRID_COORDINATES_19_x_19 =\n    _.map(_.range(1, 20), row => {\n        return _.map(UTILS.genCharArray(MIN_COLUMN, MAX_19_x_19_COLUMN), col => `${col}${row}`);\n    })\n;","import * as FLAGS from '../../game/flags';\nimport * as ACTIONS from '../constants/actions';\n\n// This maintains a map of coordinates as keys to placed stones.\n// the state is somewhat dynamic but predictable based on the\n// generally agreed upon goban coordinates\nconst initialState = {\n    alteredStones: new Set(),\n    mode: FLAGS.GAME_9_x_9,\n    koViolation: '',\n    currentBoardState: {},\n    previousBoardState: {},\n    previousStone: '',\n    penultimateStone: '', // means 'second to last', quite literally\n};\n\nconst board = (state = initialState, action) => {\n    switch (action.type) {\n        case ACTIONS.SET_MODE:\n            const { mode } = action.payload;\n\n            return {\n                ...initialState,\n                mode,\n            };\n        case ACTIONS.UPDATE_STONES:\n            const {\n                alteredStones,\n                nextBoardState,\n                placedStone,\n            } = action.payload;\n\n            // ALTERED STONES GOES TO GAME MATHS\n            return {\n                ...state,\n                alteredStones,\n                koViolation: '',\n                currentBoardState: nextBoardState,\n                previousBoardState: state.currentBoardState,\n                penultimateStone: state.previousStone,\n                previousStone: placedStone,\n            };\n        case ACTIONS.KO_WARNING:\n            const {\n                colCoordinate,\n                rowCoordinate,\n            } = action.payload;\n\n            return {\n                ...state,\n                koViolation: `${colCoordinate}${rowCoordinate}`,\n            };\n        default:\n            return state;\n    }\n};\n\nexport default board;","export const KO_WARNING = 'KO_WARNING';\nexport const SET_MODE = 'SET_MODE';\nexport const SET_LAST_PREVIEW_STONE = 'SET_LAST_PREVIEW_STONE';\nexport const UPDATE_STONES = 'UPDATE_STONES';\nexport const SET_WINDOW_DIMENSIONS = 'SET_WINDOW_DIMENSIONS';\nexport const TOGGLE_CONFIGURATION_PANEL = 'TOGGLE_CONFIGURATION_PANEL';","import * as _ from 'lodash';\nimport * as FLAGS from './flags';\nimport * as UTILS from \"./utils\";\n\nexport const getCornersConstant = (mode) => {\n    if (FLAGS.GAME_9_x_9 === mode) {\n        return FLAGS.CORNERS_9_x_9;\n    } else if (FLAGS.GAME_13_x_13 === mode) {\n        return FLAGS.CORNERS_13_x_13;\n    } else if (FLAGS.GAME_19_x_19 === mode) {\n        return FLAGS.CORNERS_19_x_19;\n    }\n};\n\nexport const getSidesConstant = (mode) => {\n    if (FLAGS.GAME_9_x_9 === mode) {\n        return FLAGS.SIDES_9_x_9;\n    } else if (FLAGS.GAME_13_x_13 === mode) {\n        return FLAGS.SIDES_13_x_13;\n    } else if (FLAGS.GAME_19_x_19 === mode) {\n        return FLAGS.SIDES_19_x_19;\n    }\n};\n\nexport const getStarPointsConstant = (mode) => {\n    if (FLAGS.GAME_9_x_9 === mode) {\n        return FLAGS.STAR_POINTS_9_x_9;\n    } else if (FLAGS.GAME_13_x_13 === mode) {\n        return FLAGS.STAR_POINTS_13_x_13;\n    } else if (FLAGS.GAME_19_x_19 === mode) {\n        return FLAGS.STAR_POINTS_19_x_19;\n    }\n};\n\nexport const getCardinalDirection = (mode, coordinate) => {\n    if (FLAGS.CORNER_ALL_NW === coordinate) {\n        return FLAGS.NORTH_WEST;\n    } \n    \n    if (FLAGS.GAME_9_x_9 === mode) {\n        if (FLAGS.CORNER_9_x_9_SW === coordinate) {\n            return FLAGS.SOUTH_WEST;\n        } else if (FLAGS.CORNER_9_x_9_NE === coordinate) {\n            return FLAGS.NORTH_EAST;\n        } else if (FLAGS.CORNER_9_x_9_SE === coordinate) {\n            return FLAGS.SOUTH_EAST;\n        } else { // let me die I made these so cumbersome\n            if (FLAGS.MIN_COLUMN === coordinate[0]) {\n                return FLAGS.WEST;\n            } else if (FLAGS.MIN_ROW === coordinate.substring(1)) {\n                return FLAGS.NORTH;\n            } else if (FLAGS.MAX_9_x_9_COLUMN === coordinate[0]) {\n                return FLAGS.EAST;\n            } else if (FLAGS.MAX_9_x_9_ROW === coordinate.substring(1)) {\n                return FLAGS.SOUTH;\n            }\n        }\n\n        throw new Error('Avast ye matey, shouldn\"nt be branching to this island in 9 x 9');\n    }\n\n    if (FLAGS.GAME_13_x_13 === mode) {\n        if (FLAGS.CORNER_13_x_13_SW === coordinate) {\n            return FLAGS.SOUTH_WEST;\n        } else if (FLAGS.CORNER_13_x_13_NE === coordinate) {\n            return FLAGS.NORTH_EAST;\n        } else if (FLAGS.CORNER_13_x_13_SE === coordinate) {\n            return FLAGS.SOUTH_EAST;\n        } else { // let me die I made these so cumbersome\n            if (FLAGS.MIN_COLUMN === coordinate[0]) {\n                return FLAGS.WEST;\n            } else if (FLAGS.MIN_ROW === coordinate.substring(1)) {\n                return FLAGS.NORTH;\n            } else if (FLAGS.MAX_13_x_13_COLUMN === coordinate[0]) {\n                return FLAGS.EAST;\n            } else if (FLAGS.MAX_13_x_13_ROW === coordinate.substring(1)) {\n                return FLAGS.SOUTH;\n            }\n        }\n\n        throw new Error('Avast ye matey, shouldn\"nt be branching to this island in 13 x 13');\n    }\n\n    if (FLAGS.GAME_19_x_19 === mode) {\n        if (FLAGS.CORNER_19_x_19_SW === coordinate) {\n            return FLAGS.SOUTH_WEST;\n        } else if (FLAGS.CORNER_19_x_19_NE === coordinate) {\n            return FLAGS.NORTH_EAST;\n        } else if (FLAGS.CORNER_19_x_19_SE === coordinate) {\n            return FLAGS.SOUTH_EAST;\n        } else { // let me die I made these so cumbersome\n            if (FLAGS.MIN_COLUMN === coordinate[0]) {\n                return FLAGS.WEST;\n            } else if (FLAGS.MIN_ROW === coordinate.substring(1)) {\n                return FLAGS.NORTH;\n            } else if (FLAGS.MAX_19_x_19_COLUMN === coordinate[0]) {\n                return FLAGS.EAST;\n            } else if (FLAGS.MAX_19_x_19_ROW === coordinate.substring(1)) {\n                return FLAGS.SOUTH;\n            }\n        }\n\n        throw new Error('Avast ye matey, shouldn\"nt be branching to this island in 19 x 19');\n    }    \n};\n\n// Calculates how much space the board can have on the screen\nexport const calculateBoardDimensions = ({\n                                     windowHeight,\n                                     windowWidth,\n                                 }) => {\n    let desiredWidth = windowHeight * FLAGS.GOBAN_HEIGHT_TO_WIDTH_RATIO;\n    desiredWidth = windowWidth > desiredWidth ? desiredWidth : windowWidth - 10; // very scientific\n    const desiredHeight = desiredWidth * FLAGS.GOBAN_WIDTH_TO_HEIGHT_RATIO;\n\n    return {\n        height: Math.floor(desiredHeight),\n        width: Math.floor(desiredWidth),\n    };\n};\n\n//https://senseis.xmp.net/?EquipmentDimensions\n// This function determines the width and height of each renderable tile.\n// corners and sides will get an additional padding for aesthetic.\nexport const calculateTileDimensions = ({\n                                     mode,\n                                     boardHeight,\n                                     boardWidth,\n                                 }) => {\n    let tileRatio = 0;\n\n    if (FLAGS.GAME_9_x_9 === mode) {\n        tileRatio = Number(1/9);\n    } else if (FLAGS.GAME_13_x_13 === mode) {\n        tileRatio = Number(1/13);\n    } else if (FLAGS.GAME_19_x_19 === mode) {\n        tileRatio = Number(1/19);\n    } else {\n        throw new Error('No known mode');\n    }\n    \n    const height = Math.floor(boardHeight * tileRatio);\n    const width = Math.floor(boardWidth * tileRatio);\n\n    // Otherwise these calculations will cause lines to be drawn outside\n    // the bounding canvas\n    return {\n        height: height % 2 === 0 ? height : height - 1,\n        width: width % 2 === 0 ? width : width - 1,\n    };\n};\n\nexport const stoneRadius = (tileHeight) => {\n    return Math.floor((tileHeight * FLAGS.GOBAN_STONE_DIAMETER_TO_TILE_HEIGHT_RATIO) / 2);\n};\n\nexport const getCardinalAdjacencies = ({\n    mode,\n    colCoordinate,\n    rowCoordinate,\n}) => {\n    let coordinates;\n\n    if (FLAGS.GAME_9_x_9 === mode) {\n        coordinates = FLAGS.GRID_COORDINATES_9_x_9;\n    } else if (FLAGS.GAME_13_x_13 === mode) {\n        coordinates = FLAGS.GRID_COORDINATES_13_x_13;\n    } else if (FLAGS.GAME_19_x_19 === mode) {\n        coordinates = FLAGS.GRID_COORDINATES_19_x_19;\n    }\n\n    const maxIndex = coordinates.length - 1;\n\n    // 'a' is ASCII 97\n    const colIndex = parseInt(colCoordinate.charCodeAt(0) - 97);\n    const rowIndex = parseInt(rowCoordinate) - 1; // 0 indexed, dummy\n\n    const adjacencies = {};\n\n    if (rowIndex >= 1) {\n        adjacencies.north = coordinates[rowIndex - 1][colIndex];\n    }\n\n    if (colIndex < maxIndex) {\n        adjacencies.east = coordinates[rowIndex][colIndex + 1];\n    }\n\n    if (rowIndex < maxIndex) {\n        adjacencies.south = coordinates[rowIndex + 1][colIndex];\n    }\n\n    if (colIndex >= 1) {\n        adjacencies.west = coordinates[rowIndex][colIndex - 1];\n    }\n\n    return adjacencies;\n};\n\nexport const getAdjacentCoordinates = ({\n   mode,\n   colCoordinate,\n   rowCoordinate,\n}) => _.values(getCardinalAdjacencies({\n    mode,\n    colCoordinate,\n    rowCoordinate,\n}));\n\n// get adjacent stones of opposing color\n// get all connected stones in that opposing color group\n// determine if any of those connected stones have any liberties\n// return board state with dead groups removed\n// TODO: this can't be 100 lines long...\n\nexport const removeDeadStones = ({\n    existingStones,\n    mode,\n    newStoneColor,\n    newStoneColCoordinate,\n    newStoneRowCoordinate,\n}) => {\n    const opposingColor = FLAGS.STONE_BLACK === newStoneColor ? FLAGS.STONE_WHITE : FLAGS.STONE_BLACK;\n    const newStones = _.assign({}, existingStones, { [`${newStoneColCoordinate}${newStoneRowCoordinate}`]: newStoneColor });\n\n    // this will make sense in a few lines.. maybe\n    let cardinalAdjacencyMap = getCardinalAdjacencies({\n        mode,\n        colCoordinate: newStoneColCoordinate,\n        rowCoordinate: newStoneRowCoordinate,\n    });\n\n    let nextAdjacentCoordinates = [];\n\n    // Need to track the attacked groups separately to ensure proper removal\n    const attackedGroups = {\n        north: {\n            stones: [],\n            liberties: [],\n        },\n        east: {\n            stones: [],\n            liberties: [],\n        },\n        south: {\n            stones: [],\n            liberties: [],\n        },\n        west: {\n            stones: [],\n            liberties: [],\n        },\n    };\n\n    const isCoordinateProcessed = (coordinate) => {\n        for (const direction in attackedGroups) {\n            if (_.includes(attackedGroups[direction].stones, coordinate)) {\n                return true;\n            }\n        }\n\n        return false;\n    };\n\n    const shouldProcessCoordinate = (coordinate) => {\n        if (isCoordinateProcessed(coordinate)) {\n            return false;\n        }\n\n        if (newStones[coordinate] === opposingColor) {\n            return true;\n        }\n\n        return false;\n    };\n\n    for (const direction in cardinalAdjacencyMap) {\n        const coordinate = cardinalAdjacencyMap[direction];\n        const attackedGroup = attackedGroups[direction];\n\n        // For a while I forgot to process the initial coordinate. Smart.\n        if (shouldProcessCoordinate(coordinate)) {\n            nextAdjacentCoordinates.push(coordinate);\n            attackedGroup.stones.push(coordinate);\n        }\n\n        do {\n            // ... get adjacent allied stones and ones not already part of the group\n            nextAdjacentCoordinates = _.flatMap(nextAdjacentCoordinates, (coordinateToProcess) =>\n                _.filter(getAdjacentCoordinates({\n                    mode,\n                    colCoordinate: coordinateToProcess[0],\n                    rowCoordinate: coordinateToProcess.substring(1),\n                }), shouldProcessCoordinate)\n            );\n\n            attackedGroup.stones.push.apply(attackedGroup.stones, nextAdjacentCoordinates);\n        } while (nextAdjacentCoordinates.length !== 0);\n    }\n\n    for (const direction in attackedGroups) {\n        const attackedGroup = attackedGroups[direction];\n\n        for (const coordinateToProcess of attackedGroup.stones) {\n            nextAdjacentCoordinates = _.filter(getAdjacentCoordinates({\n                mode,\n                colCoordinate: coordinateToProcess[0],\n                rowCoordinate: coordinateToProcess.substring(1),\n            }), aCoordinate => !isCoordinateProcessed(aCoordinate)\n                && (!newStones[aCoordinate] || newStones[aCoordinate] === FLAGS.STONE_NONE));\n\n            attackedGroup.liberties.push.apply(attackedGroup.liberties, nextAdjacentCoordinates);\n        }\n    }\n\n    const stonesToRemove = [];\n    let survivingAttackedGroups = 0;\n\n    for (const direction in attackedGroups) {\n        const attackedGroup = attackedGroups[direction];\n\n        if (attackedGroup.liberties.length === 0) {\n            stonesToRemove.push.apply(stonesToRemove, attackedGroup.stones);\n        } else if (attackedGroup.stones.length > 0) {\n            survivingAttackedGroups++;\n        }\n    }\n\n    if (survivingAttackedGroups === _.keys(cardinalAdjacencyMap).length) {\n        return existingStones; // the placed stone died\n    }\n\n    for (const coordinate of stonesToRemove) {\n        newStones[coordinate] = FLAGS.STONE_NONE;\n    }\n\n    return newStones;\n};\n\nexport const determineAlteredstones = ({ nextBoardState, currentBoardState }) => {\n    const alteredStones = new Set();\n\n    for (const coordinate in nextBoardState) {\n        if (nextBoardState[coordinate] !== currentBoardState[coordinate]) {\n            alteredStones.add(coordinate);\n        }\n    }\n\n    return alteredStones;\n};\n\nexport const getOffsets = ({ x, y, tileDimensions }) => {\n    const col = Math.floor(x / tileDimensions.width);\n    const row = Math.floor(y / tileDimensions.height);\n\n    return {\n        col,\n        row,\n    };\n};\n\nexport const deriveCoordinatesFromOffsets = (offsets) => {\n    const colCoordinate = UTILS.getCharacterFromOffset(offsets.col);\n    const rowCoordinate = offsets.row + 1;\n\n    return {\n        colCoordinate,\n        rowCoordinate,\n    };\n};","import * as FLAGS from '../../game/flags';\nimport * as ACTIONS from '../constants/actions';\nimport * as GAME_MATHS from \"../../game/maths\";\n\nconst initialState = {\n    boardDimensions: {\n        height: 0,\n        width: 0,\n    },\n    canRender: false,\n    configurationPanelShown: false,\n    maxOffsets: {\n        col: 8,\n        row: 8,\n    },\n    mode: FLAGS.GAME_9_x_9,\n    tileDimensions: {\n        height: 0,\n        width: 0,\n    },\n    turnColor: FLAGS.TURN_BLACK,\n    turnNumber: 1,\n    windowHeight: null,\n    windowWidth: null,\n    blackCaptures: 0,\n    whiteCaptures: 0,\n    lastPreviewStone: '',\n};\n\nconst getDimensions = ({ mode, windowHeight, windowWidth }) => {\n    const boardDimensions =\n        GAME_MATHS.calculateBoardDimensions({\n            windowHeight,\n            windowWidth,\n        });\n\n    const tileDimensions =\n        GAME_MATHS.calculateTileDimensions({\n            mode,\n            boardHeight: boardDimensions.height,\n            boardWidth: boardDimensions.width,\n        });\n\n    return {\n        boardDimensions,\n        tileDimensions,\n    }\n};\n\nconst game = (state = initialState, action) => {\n    switch (action.type) {\n        case ACTIONS.SET_LAST_PREVIEW_STONE: {\n            return {\n                ...state,\n                lastPreviewStone: action.payload.coordinate,\n            }\n        }\n        case ACTIONS.SET_MODE: {\n            const { mode } = action.payload;\n\n            const {\n                boardDimensions,\n                tileDimensions,\n            } = getDimensions({\n                mode,\n                windowHeight: state.windowHeight,\n                windowWidth: state.windowWidth,\n            });\n\n            let maxOffsets = {\n                col: 8,\n                row: 8,\n            };\n\n            if (mode === FLAGS.GAME_13_x_13) {\n                maxOffsets.col = 12;\n                maxOffsets.row = 12;\n            } else if (mode === FLAGS.GAME_19_x_19) {\n                maxOffsets.col = 18;\n                maxOffsets.row = 18;\n            }\n\n            return {\n                ...state,\n                maxOffsets,\n                mode,\n                boardDimensions,\n                tileDimensions,\n                turnNumber: 1,\n                blackCaptures: 0,\n                whiteCaptures: 0,\n            };\n        } \n        case ACTIONS.UPDATE_STONES:\n            return {\n                ...state,\n                turnColor: state.turnColor === FLAGS.TURN_BLACK ? FLAGS.TURN_WHITE : FLAGS.TURN_BLACK,\n                turnNumber: state.turnNumber + 1,\n            };\n        case ACTIONS.SET_WINDOW_DIMENSIONS: {\n            const {\n                windowHeight,\n                windowWidth,\n            } = action.payload;\n\n            const {\n                boardDimensions,\n                tileDimensions,\n            } = getDimensions({\n                mode: state.mode,\n                windowHeight,\n                windowWidth,\n            });\n\n            return {\n                ...state,\n                boardDimensions,\n                tileDimensions,\n                canRender: true,\n                windowHeight,\n                windowWidth,\n            };\n        } \n        case ACTIONS.TOGGLE_CONFIGURATION_PANEL: {\n           return {\n               ...state,\n               configurationPanelShown: !state.configurationPanelShown,\n           } \n        }\n        default:\n            return state;\n    }\n};\n\nexport default game;","import * as TYPES from '../constants/actions';\nimport * as FLAGS from '../../game/flags';\nimport * as GAME_MATHS from '../../game/maths';\nimport * as _ from 'lodash';\n\nconst updateStones = ({\n    alteredStones,\n    nextBoardState,\n    placedStone,\n}) => ({\n    type: TYPES.UPDATE_STONES,\n    payload: {\n        alteredStones,\n        nextBoardState,\n        placedStone,\n    },\n});\n\nconst koWarning = (colCoordinate, rowCoordinate, color) => ({\n    type: TYPES.KO_WARNING,\n    payload: {\n        colCoordinate,\n        rowCoordinate,\n        color,\n    }\n});\n\nexport const setStone = ({ colCoordinate, rowCoordinate }) => {\n    return (dispatch, getState) => {\n        const {\n            mode,\n            turnColor,\n        } = getState().game;\n\n        const {\n            currentBoardState,\n            previousBoardState,\n        } = getState().board;\n\n        const color = FLAGS.TURN_BLACK === turnColor ? FLAGS.STONE_BLACK : FLAGS.STONE_WHITE;\n\n        const nextBoardState = GAME_MATHS.removeDeadStones({\n            existingStones: currentBoardState,\n            mode,\n            newStoneColor: color,\n            newStoneColCoordinate: colCoordinate,\n            newStoneRowCoordinate: rowCoordinate,\n        });\n\n        const isKo = _.isEqual(previousBoardState, nextBoardState);\n\n        if (isKo) {\n            dispatch(koWarning(colCoordinate, rowCoordinate, color));\n        } else {\n            // TEST THIS\n            const alteredStones = GAME_MATHS.determineAlteredstones({ currentBoardState, nextBoardState});\n\n            dispatch(updateStones({\n                alteredStones,\n                nextBoardState,\n                placedStone: `${colCoordinate}${rowCoordinate}`,\n            }));\n        }\n    };\n};","import React, { Component } from 'react';\nimport { connect } from 'react-redux';\nimport * as _ from 'lodash';\nimport * as FLAGS from './game/flags';\nimport * as GAME_MATHS from './game/maths';\nimport * as UTILS from './game/utils';\nimport { setStone } from './store/actions/board';\nimport { setLastPreviewStone } from './store/actions/game';\n\nclass Board extends Component {\n    constructor(props) {\n        super(props);\n        this.onMouseMove = this.onMouseMove.bind(this);\n        this.onMouseOut = this.onMouseOut.bind(this);\n        this.onClick = this.onClick.bind(this);\n        this.calculatePreviewStone = this.calculatePreviewStone.bind(this);\n        // this.calculatePreviewStone = _.throttle(this.calculatePreviewStone.bind(this), 100);\n    }\n\n    componentDidMount() {\n        this.renderWholeBoard();\n    }\n\n    componentDidUpdate(prevProps) {\n        if (this.props.mode !== prevProps.mode ||\n            !_.isEqual(this.props.tileDimensions, prevProps.tileDimensions)) {\n            const { boardDimensions } = this.props;\n\n            const canvasContext = this.getCanvasContextPresets();\n            canvasContext.clearRect(0, 0, boardDimensions.width, boardDimensions.height);\n            this.renderWholeBoard();\n        } else if (!_.isEqual(this.props.alteredStones, prevProps.alteredStones)) {\n            for (const coordinate of this.props.alteredStones) {\n                const colCoordinate = coordinate[0];\n                const rowCoordinate = Number.parseInt(coordinate.substring(1));\n                const colOffset = UTILS.getOffsetFromCharacter(colCoordinate);\n                const rowOffset = rowCoordinate - 1;\n                const canvasContext = this.getCanvasContextPresets();\n\n                this.drawTile(colCoordinate, rowCoordinate, canvasContext, colOffset, rowOffset);\n            }\n        }\n    }\n\n    getCoordinates() {\n        const { mode } = this.props;\n\n        // Yay hardcoding\n        if (mode === FLAGS.GAME_9_x_9) {\n            return FLAGS.GRID_COORDINATES_9_x_9;\n        } else if (mode === FLAGS.GAME_13_x_13) {\n            return FLAGS.GRID_COORDINATES_13_x_13;\n        } else if (mode === FLAGS.GAME_19_x_19) {\n            return FLAGS.GRID_COORDINATES_19_x_19;\n        } else {\n            throw new Error('No known mode selected');\n        }\n    }\n\n    getCanvasContextPresets() {\n        const { isKoViolation } = this.props;\n\n        const canvas = this.refs.canvas;\n        const canvasContext = canvas.getContext('2d');\n        canvasContext.lineWidth = 4; // 4 pixels is a little over a millimeter. Yeah I know mobile yada yada\n\n        if (isKoViolation) {\n            canvasContext.strokeStyle = '#FF0000';\n        }\n\n        return canvasContext;\n    }\n\n    drawTile(colCoordinate, rowCoordinate, canvasContext, colOffset, rowOffset) {\n        const {\n            currentBoardState,\n            mode,\n        } = this.props;\n\n        // const stonePlaced = currentBoardState[`${colCoordinate}${rowCoordinate}`];\n        //\n        // // Render the stone first, that way we can clear appropriately\n        // // when the component is updated.\n        // if (!stonePlaced || FLAGS.STONE_NONE === stonePlaced) {\n        //     this.clearCanvas(canvasContext, colOffset, rowOffset);\n        // } else {\n        //     this.drawStone(canvasContext, colOffset, rowOffset, stonePlaced);\n        // }\n\n        const stonePlaced = currentBoardState[`${colCoordinate}${rowCoordinate}`];\n\n        if (stonePlaced === FLAGS.STONE_NONE) {\n            this.clearCanvas(canvasContext, colOffset, rowOffset);\n        }\n\n        if (GAME_MATHS.getCornersConstant(mode).includes(`${colCoordinate}${rowCoordinate}`)) {\n            this.drawCorner(colCoordinate, rowCoordinate, canvasContext, colOffset, rowOffset);\n        } else if (GAME_MATHS.getSidesConstant(mode).includes(`${colCoordinate}${rowCoordinate}`)) {\n            this.drawSide(colCoordinate, rowCoordinate, canvasContext, colOffset, rowOffset);\n        } else if (GAME_MATHS.getStarPointsConstant(mode).includes(`${colCoordinate}${rowCoordinate}`)) {\n            this.drawStarPoint(canvasContext, colOffset, rowOffset);\n        } else {\n            this.drawIntersection(canvasContext, colOffset, rowOffset);\n        }\n\n        if (stonePlaced && FLAGS.STONE_NONE !== stonePlaced) {\n            this.drawStone(canvasContext, colOffset, rowOffset, stonePlaced);\n        }\n    }\n\n    drawSide(colCoordinate, rowCoordinate, canvasContext, colOffset, rowOffset) {\n        const {\n            mode,\n            tileDimensions,\n        } = this.props;\n\n        const cardinalDirection = GAME_MATHS.getCardinalDirection(mode, `${colCoordinate}${rowCoordinate}`);\n\n        const min_X = tileDimensions.width * colOffset;\n        const min_Y = tileDimensions.height * rowOffset;\n        const mid_X = min_X + (tileDimensions.width / 2);\n        const mid_Y = min_Y + (tileDimensions.height / 2);\n        const max_X = min_X + tileDimensions.width;\n        const max_Y = min_Y + tileDimensions.height;\n\n        canvasContext.beginPath();\n        canvasContext.font = '18px monospace';\n\n        if (FLAGS.WEST === cardinalDirection) {\n            canvasContext.moveTo(mid_X, min_Y);\n            canvasContext.lineTo(mid_X, max_Y);\n            canvasContext.moveTo(mid_X, mid_Y);\n            canvasContext.lineTo(max_X, mid_Y);\n            canvasContext.fillText(rowCoordinate, min_X, mid_Y + 4);\n        } else if (FLAGS.NORTH === cardinalDirection) {\n            canvasContext.moveTo(min_X, mid_Y);\n            canvasContext.lineTo(max_X, mid_Y);\n            canvasContext.moveTo(mid_X, mid_Y);\n            canvasContext.lineTo(mid_X, max_Y);\n            canvasContext.fillText(colCoordinate, mid_X, 18);\n        } else if (FLAGS.EAST === cardinalDirection) {\n            canvasContext.moveTo(mid_X, min_Y);\n            canvasContext.lineTo(mid_X, max_Y);\n            canvasContext.moveTo(min_X, mid_Y);\n            canvasContext.lineTo(mid_X, mid_Y);\n            canvasContext.fillText(rowCoordinate, max_X - 20, mid_Y + 4);\n        } else if (FLAGS.SOUTH === cardinalDirection) {\n            canvasContext.moveTo(min_X, mid_Y);\n            canvasContext.lineTo(max_X, mid_Y);\n            canvasContext.moveTo(mid_X, min_Y);\n            canvasContext.lineTo(mid_X, mid_Y);\n            canvasContext.fillText(colCoordinate, mid_X, max_Y - 10);\n        }\n\n        canvasContext.stroke();\n    }\n\n    drawCorner(colCoordinate, rowCoordinate, canvasContext, colOffset, rowOffset) {\n        const {\n            mode,\n            tileDimensions,\n        } = this.props;\n\n        const cardinalDirection = GAME_MATHS.getCardinalDirection(mode, `${colCoordinate}${rowCoordinate}`);\n\n        const min_X = tileDimensions.width * colOffset;\n        const min_Y = tileDimensions.height * rowOffset;\n        const mid_X = min_X + (tileDimensions.width / 2);\n        const mid_Y = min_Y + (tileDimensions.height / 2);\n        const max_X = min_X + tileDimensions.width;\n        const max_Y = min_Y + tileDimensions.height;\n\n        canvasContext.beginPath();\n        canvasContext.font = '18px monospace';\n\n        if (FLAGS.NORTH_EAST === cardinalDirection) {\n            canvasContext.moveTo(min_X, mid_Y);\n            canvasContext.lineTo(mid_X, mid_Y);\n            canvasContext.lineTo(mid_X, max_Y);\n            canvasContext.fillText(colCoordinate, mid_X - 4, 18);\n            canvasContext.fillText(rowCoordinate, max_X - 20, mid_Y + 4);\n        } else if (FLAGS.SOUTH_EAST === cardinalDirection) {\n            canvasContext.moveTo(mid_X, min_Y);\n            canvasContext.lineTo(mid_X, mid_Y);\n            canvasContext.lineTo(min_X, mid_Y);\n            canvasContext.fillText(colCoordinate, mid_X - 4, max_Y - 10);\n            canvasContext.fillText(rowCoordinate, max_X - 20, mid_Y);\n        } else if (FLAGS.SOUTH_WEST === cardinalDirection) {\n            canvasContext.moveTo(max_X, mid_Y);\n            canvasContext.lineTo(mid_X, mid_Y);\n            canvasContext.lineTo(mid_X, min_Y);\n            canvasContext.fillText(colCoordinate, mid_X, max_Y - 10);\n            canvasContext.fillText(rowCoordinate, min_X, mid_Y);\n        } else if (FLAGS.NORTH_WEST === cardinalDirection) {\n            canvasContext.moveTo(mid_X, max_Y);\n            canvasContext.lineTo(mid_X, mid_Y);\n            canvasContext.lineTo(max_X, mid_Y);\n            canvasContext.fillText(colCoordinate, mid_X, 18);\n            canvasContext.fillText(rowCoordinate, min_X, mid_Y);\n        }\n\n        canvasContext.stroke();\n    }\n\n    drawIntersection(canvasContext, colOffset, rowOffset) {\n        const { tileDimensions } = this.props;\n\n        const min_X = tileDimensions.width * colOffset;\n        const min_Y = tileDimensions.height * rowOffset;\n        const mid_X = min_X + (tileDimensions.width / 2);\n        const mid_Y = min_Y + (tileDimensions.height / 2);\n        const max_X = min_X + tileDimensions.width;\n        const max_Y = min_Y + tileDimensions.height;\n\n        canvasContext.beginPath();\n        canvasContext.moveTo(min_X, mid_Y);\n        canvasContext.lineTo(max_X, mid_Y);\n        canvasContext.moveTo(mid_X, min_Y);\n        canvasContext.lineTo(mid_X, max_Y);\n        canvasContext.stroke();\n    }\n\n    drawStarPoint(canvasContext, colOffset, rowOffset) {\n        const { tileDimensions } = this.props;\n\n        const min_X = tileDimensions.width * colOffset;\n        const min_Y = tileDimensions.height * rowOffset;\n        const mid_X = min_X + (tileDimensions.width / 2);\n        const mid_Y = min_Y + (tileDimensions.height / 2);\n        const max_X = min_X + tileDimensions.width;\n        const max_Y = min_Y + tileDimensions.height;\n\n        canvasContext.beginPath();\n        canvasContext.arc(mid_X, mid_Y, 5, 0, 2 * Math.PI);\n        canvasContext.fillStyle = '#000000';\n        canvasContext.fill();\n        canvasContext.moveTo(min_X, mid_Y);\n        canvasContext.lineTo(max_X, mid_Y);\n        canvasContext.moveTo(mid_X, min_Y);\n        canvasContext.lineTo(mid_X, max_Y);\n        canvasContext.stroke();\n    }\n\n    drawStone(canvasContext, colOffset, rowOffset, stonePlaced) {\n        this.drawStoneInternal(FLAGS.STONE_BLACK === stonePlaced, canvasContext, colOffset, rowOffset);\n    }\n\n    drawStoneInternal(isBlack, canvasContext, colOffset, rowOffset) {\n        const {\n            stoneRadius,\n            tileDimensions,\n        } = this.props;\n\n        const min_X = tileDimensions.width * colOffset;\n        const min_Y = tileDimensions.height * rowOffset;\n        const mid_X = min_X + (tileDimensions.width / 2);\n        const mid_Y = min_Y + (tileDimensions.height / 2);\n\n        canvasContext.beginPath();\n        canvasContext.arc(mid_X, mid_Y, stoneRadius, 0, 2 * Math.PI);\n\n        if (isBlack) {\n            canvasContext.fillStyle = '#000000';\n            canvasContext.fill();\n        } else {\n            canvasContext.fillStyle = '#FFFFFF';\n            canvasContext.fill();\n        }\n\n        canvasContext.stroke();\n    }\n\n    resetLastPreviewStone(canvasContext) {\n        const { lastPreviewStone } = this.props;\n\n        if (lastPreviewStone) {\n            const previousColOffset = UTILS.getOffsetFromCharacter(lastPreviewStone[0]);\n            const previousRowOffset = Number.parseInt(lastPreviewStone.substring(1)) - 1;\n\n            this.clearCanvas(canvasContext, previousColOffset, previousRowOffset);\n            this.drawTile(lastPreviewStone[0], lastPreviewStone.substring(1), canvasContext, previousColOffset, previousRowOffset);\n        }\n    }\n\n    showPreviewStone(colOffset, rowOffset) {\n        const {\n            currentBoardState,\n            lastPreviewStone,\n            setLastPreviewStone,\n            turnColor,\n        } = this.props;\n\n        const canvasContext = this.getCanvasContextPresets();\n\n        const currentColCoordinate = UTILS.getCharacterFromOffset(colOffset);\n        const currentRowCoordinate = rowOffset + 1;\n\n        const coordinate = `${currentColCoordinate}${currentRowCoordinate}`;\n\n        // Don't go through re-render if it's the same stone\n        if (coordinate === lastPreviewStone) {\n            return;\n        }\n\n        // DRY but lame?\n        this.resetLastPreviewStone(canvasContext);\n\n        // Don't render preview stone if a stone is already there\n        if (currentBoardState[coordinate] && currentBoardState[coordinate] !== FLAGS.STONE_NONE) {\n            return;\n        }\n\n        setLastPreviewStone(coordinate);\n        this.drawStoneInternal(FLAGS.TURN_BLACK === turnColor, canvasContext, colOffset, rowOffset);\n    }\n\n    clearCanvas(canvasContext, colOffset, rowOffset) {\n        const { tileDimensions } = this.props;\n\n        const min_X = tileDimensions.width * colOffset;\n        const min_Y = tileDimensions.height * rowOffset;\n\n        canvasContext.clearRect(min_X, min_Y, tileDimensions.width, tileDimensions.height);\n    }\n\n    renderRow(aRow, rowIndex, canvasContext) {\n        const numberCoordinate = aRow[0].substring(1);\n\n        _.forEach(aRow, (aCoordinate, colIndex) => {\n            const letterCoordinate = aCoordinate[0];\n            \n            this.drawTile(letterCoordinate, numberCoordinate, canvasContext, colIndex, rowIndex);\n        });\n    }\n\n    renderWholeBoard() {\n        const coordinates = this.getCoordinates();\n        const canvasContext = this.getCanvasContextPresets();\n\n        _.forEach(coordinates, (aRow, index) => {\n            this.renderRow(aRow, index, canvasContext);\n        });\n    }\n\n    getOffsetsWithinBounds({x, y}) {\n        const {\n            tileDimensions,\n            maxOffsets,\n        } = this.props;\n        const offsets = GAME_MATHS.getOffsets({ x, y, tileDimensions});\n\n        if (offsets.col > maxOffsets.col || offsets.row > maxOffsets.row) {\n            throw new Error(`Offsets out of bounds: ${JSON.stringify(offsets)}, bounds: ${JSON.stringify(maxOffsets)}`);\n        }\n\n        return offsets;\n    }\n\n    calculatePreviewStone(x, y) {\n        let offsets;\n\n        try {\n            offsets = this.getOffsetsWithinBounds({ x, y });\n        } catch (e) {\n            console.log(e);\n            return;\n        }\n\n        this.showPreviewStone(offsets.col, offsets.row, x, y);\n    }\n\n    onClick(e) {\n        const {\n            currentBoardState,\n            setStone,\n        } = this.props;\n\n        let offsets;\n\n        try {\n            offsets = this.getOffsetsWithinBounds({\n                x: e.clientX,\n                y: e.clientY,\n            });\n        } catch (e) {\n            console.log(e);\n            return;\n        }\n\n        const coordinates = GAME_MATHS.deriveCoordinatesFromOffsets(offsets);\n        const theCoordinate = `${coordinates.colCoordinate}${coordinates.rowCoordinate}`;\n\n        if (currentBoardState[theCoordinate] && currentBoardState[theCoordinate] !== FLAGS.STONE_NONE) {\n            return;\n        }\n\n        // a little hacky, wutevs\n        setStone({ ...coordinates });\n    }\n\n    onMouseOut() {\n        const canvasContext = this.getCanvasContextPresets();\n\n        // DRY but lame?\n        this.resetLastPreviewStone(canvasContext);\n        this.props.setLastPreviewStone('');\n    }\n\n    onMouseMove(e) {\n        const clientX = e.clientX;\n        const clientY = e.clientY;\n\n        this.calculatePreviewStone(clientX, clientY);\n    }\n\n    // I may have reversed this? https://senseis.xmp.net/?Coordinates\n    render() {\n        const { boardDimensions } = this.props;\n\n        return (\n            <canvas\n                height={boardDimensions.height}\n                width={boardDimensions.width}\n                onMouseMove={this.onMouseMove}\n                onMouseOut={this.onMouseOut}\n                onClick={this.onClick}\n                ref=\"canvas\"\n            />\n        );\n    }\n}\n\nconst mapStateToProps = (state) => {\n    const {\n        mode,\n        boardDimensions,\n        lastPreviewStone,\n        maxOffsets,\n        tileDimensions,\n        turnColor,\n    } = state.game;\n\n    const {\n        alteredStones,\n        currentBoardState,\n        koViolation,\n    } = state.board;\n\n    const stoneRadius = GAME_MATHS.stoneRadius(tileDimensions.height);\n\n    return {\n        alteredStones,\n        currentBoardState,\n        koViolation,\n        lastPreviewStone,\n        maxOffsets,\n        mode,\n        stoneRadius,\n        tileDimensions,\n        boardDimensions,\n        turnColor,\n    };\n};\n\nconst mapDispatchToProps = (dispatch) => {\n    return {\n        setStone: ({ colCoordinate, rowCoordinate }) => {\n            dispatch(setStone({ colCoordinate, rowCoordinate }));\n        },\n        setLastPreviewStone: (coordinate) => {\n            dispatch(setLastPreviewStone(coordinate));\n        },\n    };\n};\n\nexport default connect(\n    mapStateToProps,\n    mapDispatchToProps,\n)(Board);","import * as TYPES from '../constants/actions';\n\nexport const setMode = mode => ({\n    type: TYPES.SET_MODE,\n    payload: {\n        mode,\n    },\n});\n\nexport const showConfigurationPanel = () => ({\n    type: TYPES.TOGGLE_CONFIGURATION_PANEL,\n});\n\nexport const setLastPreviewStone = coordinate => ({\n    type: TYPES.SET_LAST_PREVIEW_STONE,\n    payload: {\n        coordinate,\n    },\n});\n\nexport const setWindowDimensions = (windowWidth, windowHeight) => ({\n    type: TYPES.SET_WINDOW_DIMENSIONS,\n    payload: {\n        windowWidth,\n        windowHeight,\n    },\n});","import React, { Component } from 'react';\nimport { connect } from 'react-redux';\nimport * as FLAGS from './game/flags';\nimport {\n    setMode,\n} from './store/actions/game';\n\nclass ConfigurationPanel extends Component {\n    getHumanReadableMode() {\n        const { mode } = this.props;\n\n        if (mode === FLAGS.GAME_9_x_9) {\n            return '9 x 9';\n        } else if (mode === FLAGS.GAME_13_x_13) {\n            return '13 x 13';\n        } else if (mode === FLAGS.GAME_19_x_19) {\n            return '19 x 19';\n        } else {\n            throw new Error('No known mode selected');\n        }\n    }\n\n    render() {\n        const {\n            configurationPanelShown,\n            mode,\n            setMode,\n        } = this.props;\n\n        let panelClasses = \"configuration-panel configuration-panel--from-right js-configuration-panel-main\";\n\n        if (configurationPanelShown) {\n            panelClasses = `${panelClasses} configuration-panel--is-visible`;\n        }\n\n        return (\n            <div id=\"configuration\" className={panelClasses}>\n                <header className=\"configuration-panel__header\">\n                    <h1>Goban Configuration</h1>\n                    <a href=\"#0\" className=\"configuration-panel__close js-configuration-close\">Close</a>\n                </header>\n\n                <div className=\"configuration-panel__container\">\n                    <div className=\"configuration-panel__content\">\n                        <div>\n                            <h4>Mode: {this.getHumanReadableMode()}</h4>\n                            <h4>Turn Number: {this.props.turnNumber}</h4>\n                        </div>\n                        <form>\n                            <select\n                                onChange={e => setMode(e.target.value)}\n                                value={mode}\n                            >\n                                <option value={FLAGS.GAME_9_x_9}>9 x 9</option>\n                                <option value={FLAGS.GAME_13_x_13}>13 x 13</option>\n                                <option value={FLAGS.GAME_19_x_19}>19 x 19</option>\n                            </select>\n                        </form>\n                    </div>\n                </div>\n            </div>\n        );\n    }\n}\n\nconst mapStateToProps = (state) => {\n    const {\n        configurationPanelShown,\n        mode,\n        turnNumber,\n    } = state.game;\n\n    return {\n        configurationPanelShown,\n        mode,\n        turnNumber,\n    };\n};\n\nconst mapDispatchToProps = dispatch => ({\n    setMode: (mode) => {\n        dispatch(setMode(mode))\n    },\n});\n\nexport default connect(\n    mapStateToProps,\n    mapDispatchToProps,\n)(ConfigurationPanel);","import React, { Component } from 'react';\nimport { connect } from 'react-redux';\nimport {\n    showConfigurationPanel,\n} from './store/actions/game';\n\nclass ConfigurationTitleTab extends Component {\n    render() {\n        const {\n            showConfigurationPanel,\n        } = this.props;\n\n        return (\n            <div id=\"configuration-title-tab\" className=\"title-tab title-tab-rotate\">\n                <h1 onClick={showConfigurationPanel}>Configuration</h1>\n            </div>\n        );\n    }\n}\n\nconst mapStateToProps = (state) => {\n    return {\n        mode: state.game.mode,\n        turnNumber: state.game.turnNumber,\n    };\n};\n\nconst mapDispatchToProps = dispatch => ({\n    showConfigurationPanel: () => {\n        dispatch(showConfigurationPanel())\n    },\n});\n\nexport default connect(\n    mapStateToProps,\n    mapDispatchToProps,\n)(ConfigurationTitleTab);","import React, { Component } from 'react';\nimport Board from './Board';\nimport ConfigurationPanel from './ConfigurationPanel';\nimport ConfigurationTitleTab from './ConfigurationTitleTab';\nimport { connect } from 'react-redux';\nimport { setWindowDimensions } from './store/actions/game';\nimport './styles/index.css';\n\nclass App extends Component {\n    // Always seems like garbage when .bind() is used\n    constructor(props) {\n        super(props);\n        this.updateWindowDimensions = this.updateWindowDimensions.bind(this);\n    }\n\n    componentDidMount() {\n        this.updateWindowDimensions();\n        window.addEventListener('resize', this.updateWindowDimensions);\n    }\n\n    componentWillUnmount() {\n        window.removeEventListener('resize', this.updateWindowDimensions);\n    }\n\n    updateWindowDimensions() {\n        this.props.setWindowDimensions(window.innerWidth, window.innerHeight);\n    }\n\n    render() {\n        const { canRender } = this.props;\n\n        return (\n            <div className=\"App\">\n                <ConfigurationTitleTab/>\n                {canRender && <Board/>}\n                {!canRender && <h1>Please wait...</h1>}\n                <ConfigurationPanel/>\n            </div>\n        );\n    }\n}\n\nconst mapStateToProps = (state) => {\n    const {\n        canRender,\n        mode,\n    } = state.game;\n\n    return {\n        mode,\n        canRender,\n    };\n};\n\nconst mapDispatchToProps = dispatch => ({\n    setWindowDimensions: (windowWidth, windowHeight) => {\n        dispatch(setWindowDimensions(windowWidth, windowHeight))\n    },\n});\n\nexport default connect(\n    mapStateToProps,\n    mapDispatchToProps,\n)(App);","import React from 'react';\nimport ReactDOM from 'react-dom';\n\n// Redux boilerplate\nimport { Provider } from 'react-redux'\nimport configureStore from './store/configureStore'\n\n// More potentially specific imports to this domain\nimport App from './App';\n\n\nconst store = configureStore();\nconst rootElement = document.getElementById('root');\n\nReactDOM.render(\n    <Provider store={store}>\n        <App />\n    </Provider>,\n    rootElement\n);\n","import { applyMiddleware, combineReducers, createStore } from 'redux';\nimport thunkMiddleware from 'redux-thunk';\nimport { composeWithDevTools } from 'redux-devtools-extension';\n\nimport loggerMiddleware from './middleware/logger';\nimport boardReducer from './reducers/board';\nimport gameReducer from './reducers/game';\n\nexport default function configureStore(preloadedState) {\n    const middlewareEnhancer = applyMiddleware(thunkMiddleware, loggerMiddleware);\n\n    const enhancers = [middlewareEnhancer];\n    const composedEnhancers = composeWithDevTools(...enhancers);\n\n    const rootReducer = combineReducers({\n        board: boardReducer,\n        game: gameReducer,\n    });\n\n    return createStore(rootReducer, preloadedState, composedEnhancers);\n}"],"sourceRoot":""}